<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="/lib/form" elementFormDefault="qualified">
    <xsd:annotation>
<xsd:documentation>/lib/form</xsd:documentation>
</xsd:annotation>
    <xsd:element name="optionalBlock">
<xsd:annotation>
<xsd:documentation>
    Foldable block that can be expanded to show more controls by checking the checkbox.

    
    
    
    
    
  </xsd:documentation>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
<xsd:attribute name="name" use="required">
<xsd:annotation>
<xsd:documentation>
      Name of the checkbox. Can be used by the server to determine
      if the block is collapsed or expanded at the time of submission.

      Note that when the block is collapsed, none of its child controls will send
      the values to the server (unlike &lt;f:advanced&gt;)
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="title" use="required">
<xsd:annotation>
<xsd:documentation>
      Human readable text that follows the checkbox.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="checked" use="required">
<xsd:annotation>
<xsd:documentation>
      initial checkbox status. true/false.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="help">
<xsd:annotation>
<xsd:documentation>
      If present, the (?) icon will be rendered on the right to show inline help.
      See @help for &lt;f:entry&gt;.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="negative">
<xsd:annotation>
<xsd:documentation>
      if present, the foldable section expands when the checkbox is unchecked.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:complexType>
</xsd:element>
    <xsd:element name="password">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true"/>
</xsd:element>
    <xsd:element name="advanced">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="editableComboBoxValue">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true"/>
</xsd:element>
    <xsd:element name="descriptorList">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="repeatable">
<xsd:annotation>
<xsd:documentation> ]
    Repeatable blocks used to present UI where the user can configure multiple entries
    of the same kind (see the Java installations configuration in the system config.)

    This tag works like &lt;j:forEach&gt; and repeatedly evaluate the body so that
    initially all the items get their own copy. This tag also evaluate the body
    once more with var=null to create a 'master copy', which is the template entry
    used when a new copy is inserted.

    h1. HTML structure
      this tag mainly produces the nested DIVs with CSS classes as follows:

      {noformat}
      &lt;div class="repeated-container"&gt;   // container for the whole thing
        &lt;div class="repeated-chunk"&gt;
          ... copy 1 ...
        &lt;div class="repeated-chunk"&gt;
          ... copy 2 ...
        ...
      {noformat}

      The 'repeated-chunk' DIVs will also have additional CSS classes that represent
      their positions among siblings:

        first : first chunk among the siblings
        last  : last chunk among the siblings
        middle: neither first nor last
        only  : it is the only chunk (automatically get first and last at the same time)

    h1. Usage Note
      The caller of this tag should define a button to add a new copy and delete
      the current copy. Such buttons should have 'repeatable-add' CSS class and
      'repeatable-delete' CSS class respectively (it can have other CSS classes),
      so that their event handlers get properly wired up.

      The positional CSS classes on 'repeated-chunk' DIVs (as explained above)
      can be used to control the visibility of such buttons. For example, this allows
      you to hide 'delete' button if there's only one item, or only show 'add' button
      on the last row. There are a few CSS classes already defined in style.css
      for this purpose.
  
    
    
    
    
    
    
  </xsd:documentation>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
<xsd:attribute name="var" use="required">
<xsd:annotation>
<xsd:documentation>
      variable that receives the item of the current iteration.
      Accessible from the body.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="varStatus">
<xsd:annotation>
<xsd:documentation>
      Status variable that indicates the loop status.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="name">
<xsd:annotation>
<xsd:documentation>
      name used in the structured form submission. Defaults to the same name as @var.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="items" use="required">
<xsd:annotation>
<xsd:documentation>
      The item collection to loop over.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="noAddButton">
<xsd:annotation>
<xsd:documentation>
      true if the default 'add' button (that adds a new copy) shouldn't be displayed.
      When you use this attribute,
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="minimum">
<xsd:annotation>
<xsd:documentation>
      At least provide this number of copies initially.
      minimum="1" is useful to make sure there's always at least one entry for the user to fill in.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:complexType>
</xsd:element>
    <xsd:element name="option">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="description">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="entry">
<xsd:annotation>
<xsd:documentation>
    An entry of the &lt;f:form&gt;, which is one logical row (that consists of
    several &lt;TR&gt; tags.

    One entry normally host one control.

    
    
    
  </xsd:documentation>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
<xsd:attribute name="title">
<xsd:annotation>
<xsd:documentation>
      Name of the entry. Think of this like a label for the control.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="description">
<xsd:annotation>
<xsd:documentation>
      If it's not obvious to the user as to what the control expects,
      specify some description text (which currently gets rendered as
      small text under the control, but that may change.)

      This text shouldn't get too long, and in recent Hudson, this feature
      is somewhat de-emphasized, in favor of the inline foldable help page
      specified via @help.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="help">
<xsd:annotation>
<xsd:documentation>
      URL to the HTML page. When this attribute is specified, the entry gets
      a (?) icon on the right, and if the user clicks it, the contents of the
      given URL is rendered as a box below the entry.

      The URL should return an HTML document wrapped in a &lt;div&gt; tag.
      The URL is interpreted to be rooted at the context path of Hudson,
      so it's normally something like "/plugin/foobar/help/abc.html".
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:complexType>
</xsd:element>
    <xsd:element name="checkbox">
<xsd:annotation>
<xsd:documentation>
    &lt;input type="checkbox"&gt; tag that takes true/false for @checked, which is more Jelly friendly.

    
    
    
    
    
    
  </xsd:documentation>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:attribute name="name" use="required">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="checked" use="required">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="value">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="id">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="onclick">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="class">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
</xsd:attribute>
</xsd:complexType>
</xsd:element>
    <xsd:element name="editableComboBox">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="validateButton">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true"/>
</xsd:element>
    <xsd:element name="textarea">
<xsd:annotation>
<xsd:documentation>
    &lt;textarea&gt; tag on steroid.
    The textarea will be rendered to fit the content. It also gets the resize handle.

    
    
    
    
  </xsd:documentation>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:attribute name="field">
<xsd:annotation>
<xsd:documentation>
      Used for databinding. TBD.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="name">
<xsd:annotation>
<xsd:documentation>
      This becomes @name of the &lt;textarea&gt; tag.
      If @field is specified, this value is inferred from it.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="value">
<xsd:annotation>
<xsd:documentation>
      The initial value of the field. This becomes the value of the &lt;textarea&gt; tag.
      If @field is specified, the current property from the "instance" object
      will be set as the initial value automatically,
      which is the recommended approach.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="checkUrl">
<xsd:annotation>
<xsd:documentation>
      If specified, the value entered in this input field will be checked (via AJAX)
      against this URL, and errors will be rendered under the text field.

      If @field is specified, this will be inferred automatically,
      which is the recommended approach.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:complexType>
</xsd:element>
    <xsd:element name="radio">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true"/>
</xsd:element>
    <xsd:element name="dropdownList">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="hetero-list">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true"/>
</xsd:element>
    <xsd:element name="rowSet">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="block">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="section">
<xsd:annotation>
<xsd:documentation>
    Section header in the form table.

    
  </xsd:documentation>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
<xsd:attribute name="title" use="required">
<xsd:annotation>
<xsd:documentation>
      The section header text.
      If null is given, the entire &lt;f:section&gt; tag becomes no-op.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:complexType>
</xsd:element>
    <xsd:element name="dropdownListBlock">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="expandableTextbox">
<xsd:annotation>
<xsd:documentation>
    single-line textbox that can be expanded into a multi-line textarea.

    This control is useful for a field that expects multiple whitespaec-separated tokens
    (such as URLs, glob patterns, etc.) When the user only enters a few tokens,
    they can keep it as a single line to save space, but to enter a large number of values,
    this can be turned into textarea for better visibility.

    If the initial value is already multi-line text, the control starts with
    textarea.

    On the server side, your program is responsible for treating ' ', \t, \r, and \n for
    separators. (StringTokenizer would do this.)

    
    
    
  </xsd:documentation>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:attribute name="field">
<xsd:annotation>
<xsd:documentation>
      Used for databinding. TBD.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="name">
<xsd:annotation>
<xsd:documentation>
      This becomes @name of the &lt;input&gt; tag.
      If @field is specified, this value is inferred from it.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="value">
<xsd:annotation>
<xsd:documentation>
      The initial value of the field. This becomes the @value of the &lt;input&gt; tag.
      If @field is specified, the current property from the "instance" object
      will be set as the initial value automatically,
      which is the recommended approach.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:complexType>
</xsd:element>
    <xsd:element name="radioBlock">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="textbox">
<xsd:annotation>
<xsd:documentation>
    Generates an input field  to be
    used inside &lt;f:entry/&gt;

    
    
    
    
  </xsd:documentation>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:attribute name="field">
<xsd:annotation>
<xsd:documentation>
      Used for databinding. TBD.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="name">
<xsd:annotation>
<xsd:documentation>
      This becomes @name of the &lt;input&gt; tag.
      If @field is specified, this value is inferred from it.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="value">
<xsd:annotation>
<xsd:documentation>
      The initial value of the field. This becomes the @value of the &lt;input&gt; tag.
      If @field is specified, the current property from the "instance" object
      will be set as the initial value automatically,
      which is the recommended approach.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="checkUrl">
<xsd:annotation>
<xsd:documentation>
      If specified, the value entered in this input field will be checked (via AJAX)
      against this URL, and errors will be rendered under the text field.

      If @field is specified, this will be inferred automatically,
      which is the recommended approach.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:complexType>
</xsd:element>
    <xsd:element name="richtextarea">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true"/>
</xsd:element>
    <xsd:element name="slave-mode">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true"/>
</xsd:element>
    <xsd:element name="helpArea">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true"/>
</xsd:element>
    <xsd:element name="repeatableDeleteButton">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true"/>
</xsd:element>
    <xsd:element name="nested">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="submit">
<xsd:annotation>
<xsd:documentation>
    Submit button themed by YUI. This should be always
    used instead of the plain &lt;input tag.

    
  </xsd:documentation>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:attribute name="value" use="required">
<xsd:annotation>
<xsd:documentation>
      The text of the submit button. Something like "submit", "OK", etc.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:complexType>
</xsd:element>
    <xsd:element name="descriptorRadioList">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="enum">
<xsd:annotation>
<xsd:documentation/>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
</xsd:complexType>
</xsd:element>
    <xsd:element name="form">
<xsd:annotation>
<xsd:documentation>
    Outer-most tag of the entire form taglib, that generates &lt;form&gt; element.

    
    
    
    
    
  </xsd:documentation>
</xsd:annotation>
<xsd:complexType mixed="true">
<xsd:sequence>
<xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
</xsd:sequence>
<xsd:attribute name="action" use="required">
<xsd:annotation>
<xsd:documentation>
      @action of the form field. The URL where the submission is sent.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="method" use="required">
<xsd:annotation>
<xsd:documentation>
      Submission method. Either post or get.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="name" use="required">
<xsd:annotation>
<xsd:documentation>
      @name of the form. In HTML this is not a mandatory attribute,
      but in Hudson you should have it for testing and page scraping,
      so this attribute is marked required.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="enctype">
<xsd:annotation>
<xsd:documentation>
      @enctype of the &lt;form&gt; HTML element.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
<xsd:attribute name="target">
<xsd:annotation>
<xsd:documentation>
      @target of the &lt;form&gt; HTML element. Works like &lt;a target="..."&gt;
      and controls which window the result of the submission goes to.
    </xsd:documentation>
</xsd:annotation>
</xsd:attribute>
</xsd:complexType>
</xsd:element>
  </xsd:schema>
