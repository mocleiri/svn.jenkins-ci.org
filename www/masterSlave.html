<html>
<head>
	<style>
	</style>
</head>
<body><div class=app>
<h1>Master/Slave Support in Hudson</h1>

<p>
Hudson supports the "master/slave" mode, where the workload of building projects are delegated to multiple "slave" nodes, allowing single Hudson installation to host a large number of projects. This document describes this mode and how to use it.

<h3>How does this work?</h3>
<p>
	A "master" is an installation of Hudson. When you weren't using the master/slave support, a master was all you had. Even in the master/slave mode, the role of a master remains the same. It will serve all HTTP requests, and it can still build projects on its own.
<p>
	Slaves are computers that are set up to build projects for a master. They don't need to run Hudson, but they do need to be configured.
<p>
	When slaves are registered to a master, a master starts distributing loads to slaves. The exact delegation behavior depends on configuration of each project. Some projects may choose to "stick" to a particular machine for a build, while others may choose to roam freely between slaves. For people accessing Hudson website, things works mostly transparently. You can still browse javadoc, see test results, download build results from a master, without ever noticing that builds were done by slaves.

<h3>Requirement for master/slave support</h3>
<p>
	To use the master/slave support, participating computers need to satisfy the following requirements:
	<ol>
		<li>
			Master needs to be able to see file systems of slaves (more precisely, the portion of the file system that Hudson uses on a slave. On Unix, this is usually done via NFS. On Windows this could be done by using <a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;304040">file sharing</a>, <a href="http://www.microsoft.com/windowsserver2003/technologies/storage/dfs/default.mspx">DFS</a>, or any other similar means.
		<li>
			Master needs to be able to modify those slave file systems with the same permissions that the slave has. Sometimes a master deletes files that were created by a slave, or vice versa. On Unix, the simplest way to achieve this is to use NIS, or use the same UID/GID for Hudson user account on all the computers.
		<li>
			Master needs to be able to execute processes remotely on slaves. On Unix, this can be done by SSH, RSH, or other similar means. On Windows, this could be done by the same protocols through <a href="http://www.cygwin.com/">cygwin</a>. <small><i>(Does Windows have native remote process invocation mechanism? Help wanted!)</i></small>
	</ol>
<p>
	Also note that the slaves are a kind of a cluster, and operating a cluster (especially a large one or heterogeneous one) is always a non-trivial task. For example, you need to make sure that all slaves have JDKs, Ant, CVS, and/or any other tools you need for builds. You need to make sure that slaves are up and running, etc. Hudson is not a clustering middleware, and therefore it doesn't make this any easier.


<h3>Example: Configuration on Unix</h3>
<p>
	This section describes my current set up of Hudson slaves that I use inside Sun for my day job.
	My master Hudson node is running on a SPARC Solaris box, and I have a few SPARC Solaris slaves and Opteron Linux slaves.
<ul>
	<li>
		Each computer has an user called <tt>hudson</tt> and a group called <tt>hudson</tt>. All computers use the same UID and GID. (If you have access to NIS, this can be done more easily.)
	<li>
		On each computer, <tt>/var/hudson</tt> directory is set as the home directory of user <tt>hudson</tt>.
	<li>
		All machines run NFSD and SSHD, and exports <tt>/var/hudson</tt>.
	<li>
		All machines have ntp client installed, and synchronize clock regularly with the same NTP server.
	<li>
		Master's <tt>/var/hudson</tt> have all the build tools beneath it --- a few versions of Ant, Maven, and JDKs. JDKs are native programs, so I have JDK copys for all the architectures I need. The directory structure looks like this:
<pre>
/var/hudson
  +- .ssh
  +- bin
  |   +- slave  (more about this below)
  +- workspace (hudson creates this file and store all data files inside)
  +- tools
      +- ant-1.5
      +- ant-1.6
      +- maven-1.0.2
      +- maven-2.0
      +- java-1.4 -> native/java-1.4 (symlink)
      +- java-1.5 -> native/java-1.5 (symlink)
      +- native -> solaris-sparcv9 (symlink; different on each computer)
      +- solaris-sparcv9
      |   +- java-1.4
      |   +- java-1.5
      +- linux-amd64
          +- java-1.4
          +- java-1.5
</pre>
	<li>
		Master's <tt>/var/hudson/.ssh</tt> has private/public key and <tt>authorized_keys</tt> so that a master can execute programs on slaves through ssh, by using <a href="http://www.google.com/search?q=ssh+keygen">public key authentication</a>.
	<li>
		On master, I have a little shell script that uses rsync to synchronize master's <tt>/var/hudson</tt> to slaves (except <tt>/var/hudson/workspace</tt>) I use this to replicate tools on all slaves.
	<li>
		<tt>/var/hudson/bin/slave</tt> is a shell script that Hudson uses to execute jobs remotely. This file is included in <tt>hudson.war</tt> (<tt>WEB-INF/slave</tt>)  This shell script has some hooks in it to allow you to absorb some difference between machines. For example, you can set <tt>PATH</tt> that the submitted remote process uses.
	<li>
		Finally all computers have other standard build tools like <tt>svn</tt> and <tt>cvs</tt> installed and available in PATH.
</ul>


<h3>Scheduling strategy</h3>
<p>
	Some slaves are faster, while others are slow. Some slaves are closer (network wise) to a master, others are far away. So doing a good build distribution is a challenge. Currently, Hudson employs the following strategy:
<ol>
	<li>If a project is configured to stick to one computer, that's always honored.
	<li>Hudson tries to build a project on the same computer that it was previously built.
	<li>Hudson tries to move long builds to slaves, because the amount of network interaction between a master and a slave tends to be logarithmic to the duration of a build (IOW, even if project A takes twice as long to build as project B, it won't require double network transfer.) So this strategy reduces the network overhead.
</ol>
<p>
	If you have interesting ideas (or better yet, implementations), please let me know.



<h3>Transition from master-only to master/slave</h3>
<p>
	Typically, you start with a master-only installation and then much later you add slaves. When you enable the master/slave mode, Hudson automatically configures all your existing projects to stick to the master node. This is a precaution to avoid disturbing existing projects, since most likely you won't be able to configure slaves correctly without trial and error. After you configure slaves successfully, you need to individually configure projects to let them roam freely. This is tedious, but it allows you to work on one project at a time.
<p>
	Projects that are newly created on master/slave-enabled Hudson will be by default configured to roam freely.



<h3>Troubleshooting tips</h3>
<ol>
	<li>
		Every time Hudson launchs a program locally/remotely, it prints out the command line to the log file. So when a remote execution fails, login to the computer that runs the master by using the same user account, and try to run the command from your shell. You tend to solve problems quickly in this way.
	<li>
		When remote programs fail to execute (like command not found), sometimes SSH reports <tt>"select : bad file number"</tt> as the error message. Try the above tip.
	<li>
		Feel free to send your trouble to <tt>users@hudson.dev.java.net</tt>
</ol>
</div></body>
</html>
